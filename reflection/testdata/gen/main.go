// Copyright 2023 jim.zoumo@gmail.com
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"os"
	"reflect"

	"github.com/dave/jennifer/jen"
)

var (
	predeclared = []reflect.Kind{
		reflect.Bool,
		reflect.Int,
		reflect.Int8,
		reflect.Int16,
		reflect.Int32,
		reflect.Int64,
		reflect.Uint,
		reflect.Uint8,
		reflect.Uint16,
		reflect.Uint32,
		reflect.Uint64,
		reflect.Uintptr,
		reflect.Float32,
		reflect.Float64,
		reflect.Complex64,
		reflect.Complex128,
		reflect.String,
	}
)

func main() {
	f := GenerateTestdata()
	file, _ := os.Create("./reflection/testdata/testdata.go")
	defer file.Close()
	f.Render(file)
}

func GenerateTestdata() *jen.File {
	f := jen.NewFile("testdata")
	f.HeaderComment("// +build !ignore_autogenerated\n")
	f.HeaderComment("// Code generated by controller-gen. DO NOT EDIT.")

	generateTypes(f)
	genereateStruct(f)
	generateUnexportedFieldStruct(f)
	generatePredeclared(f)
	genereateSlice(f)
	generateMap(f)

	return f
}

func generateTypes(f *jen.File) {
	for _, i := range predeclared {
		f.Type().Id(myType(i)).Id(i.String()).Line()
	}
	f.Type().Id("MySlice").Index().String().Line()
	f.Type().Id("MyMap").Map(jen.String()).String().Line()
}

func generatePredeclared(f *jen.File) {
	f.Type().Id("Predeclared").StructFunc(func(g *jen.Group) {
		for _, i := range predeclared {
			g.Id(Capitalize(i.String())).Id(i.String())
			g.Id(myType(i)).Id(myType(i))
		}
	}).Line()

	f.Func().Id("NewPredeclared").Params().Id("Predeclared").Block(
		jen.Return(jen.Id("Predeclared").Values(jen.DictFunc(func(d jen.Dict) {
			for _, i := range predeclared {
				v := value(i)
				d[jen.Id(Capitalize(i.String()))] = v.Clone()
				d[jen.Id(myType(i))] = jen.Id(myType(i)).Parens(v.Clone())
			}
		}))),
	).Line()

	f.Func().Params(jen.Id("p").Id("Predeclared")).Id("Values").Params().Index().Qual("reflect", "Value").BlockFunc(func(g *jen.Group) {
		g.Var().Id("values").Index().Qual("reflect", "Value")
		for _, i := range predeclared {
			g.Id("values").Op("=").Append(
				jen.Id("values"),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(Capitalize(i.String()))),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(myType(i))),
			)
		}
		g.Return(jen.Id("values"))
	})

}

func generateUnexportedFieldStruct(f *jen.File) {
	f.Type().Id("UnexportedFieldStruct").StructFunc(func(g *jen.Group) {
		g.Id("Predeclared")
		for _, i := range predeclared {
			g.Id("private" + Capitalize(i.String())).Id(i.String())
		}
	}).Line()

	f.Func().Id("NewUnexportedFieldStruct").Params().Id("UnexportedFieldStruct").Block(
		jen.Return(jen.Id("UnexportedFieldStruct").Values(jen.DictFunc(func(d jen.Dict) {
			d[jen.Id("Predeclared")] = jen.Id("NewPredeclared").Call()
			for _, i := range predeclared {
				v := value(i)
				d[jen.Id("private"+Capitalize(i.String()))] = v
			}
		}))),
	).Line()

	f.Func().Params(jen.Id("p").Id("UnexportedFieldStruct")).Id("Values").Params().Index().Qual("reflect", "Value").BlockFunc(func(g *jen.Group) {
		g.Var().Id("values").Index().Qual("reflect", "Value")
		g.Id("values").Op("=").Append(
			jen.Id("values"),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p")),
		)
		g.Return(jen.Id("values"))
	})
}

func genereateSlice(f *jen.File) {
	f.Type().Id("Slice").StructFunc(func(g *jen.Group) {
		for _, i := range predeclared {
			g.Id(Capitalize(i.String())).Index().Id(i.String())
			g.Id(Capitalize(i.String()) + "Ptr").Index().Op("*").Id(i.String())
			g.Id(myType(i)).Index().Id(myType(i))
			g.Id(myType(i) + "Ptr").Index().Op("*").Id(myType(i))
		}

		g.Id("MySlice").Id("MySlice")
		g.Id("Struct").Index().Id("Predeclared")
		g.Id("StructPtr").Index().Op("*").Id("Predeclared")
		g.Id("UnexportedFieldStruct").Index().Id("UnexportedFieldStruct")
		g.Id("UnexportedFieldStructPtr").Index().Op("*").Id("UnexportedFieldStruct")

	}).Line()

	f.Func().Id("NewSlice").Params().Id("Slice").Block(
		jen.Id("p").Op(":=").Id("NewPredeclared").Call(),
		jen.Id("uep").Op(":=").Id("NewUnexportedFieldStruct").Call(),

		jen.Return(jen.Id("Slice").Values(jen.DictFunc(func(d jen.Dict) {
			for _, i := range predeclared {
				cap := Capitalize(i.String())
				d[jen.Id(cap)] = jen.Index().Id(i.String()).Values(jen.Id("p").Dot(cap))
				d[jen.Id(cap+"Ptr")] = jen.Index().Op("*").Id(i.String()).Values(jen.Op("&").Id("p").Dot(cap))
				d[jen.Id(myType(i))] = jen.Index().Id(myType(i)).Values(jen.Id("p").Dot(myType(i)))
				d[jen.Id(myType(i)+"Ptr")] = jen.Index().Op("*").Id(myType(i)).Values(jen.Op("&").Id("p").Dot(myType(i)))
			}

			d[jen.Id("MySlice")] = jen.Id("MySlice").Values(jen.Lit("myslice"))
			d[jen.Id("Struct")] = jen.Index().Id("Predeclared").Values(jen.Id("p"))
			d[jen.Id("StructPtr")] = jen.Index().Op("*").Id("Predeclared").Values(jen.Op("&").Id("p"))
			d[jen.Id("UnexportedFieldStruct")] = jen.Index().Id("UnexportedFieldStruct").Values(jen.Id("uep"))
			d[jen.Id("UnexportedFieldStructPtr")] = jen.Index().Op("*").Id("UnexportedFieldStruct").Values(jen.Op("&").Id("uep"))
		}))),
	).Line()

	f.Func().Params(jen.Id("p").Id("Slice")).Id("Values").Params().Index().Qual("reflect", "Value").BlockFunc(func(g *jen.Group) {
		g.Var().Id("values").Index().Qual("reflect", "Value")
		for _, i := range predeclared {
			cap := Capitalize(i.String())
			g.Id("values").Op("=").Append(
				jen.Id("values"),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(cap)),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(cap+"Ptr")),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(myType(i))),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(myType(i)+"Ptr")),
			)
		}
		g.Id("values").Op("=").Append(
			jen.Id("values"),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("MySlice")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("Struct")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("StructPtr")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("UnexportedFieldStruct")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("UnexportedFieldStructPtr")),
		)

		g.Return(jen.Id("values"))
	})
}

func generateMap(f *jen.File) {

	f.Type().Id("Map").StructFunc(func(g *jen.Group) {
		for _, i := range predeclared {
			cap := Capitalize(i.String())
			g.Id(cap).Map(jen.Id(i.String())).Id(i.String())
			g.Id(cap + "Ptr").Map(jen.Id(i.String())).Op("*").Id(i.String())
			g.Id(myType(i)).Map(jen.Id(myType(i))).Id(myType(i))
			g.Id(myType(i) + "Ptr").Map(jen.Id(myType(i))).Op("*").Id(myType(i))
		}

		g.Id("MyMap").Id("MyMap")
		g.Id("Struct").Map(jen.String()).Id("Predeclared")
		g.Id("StructPtr").Map(jen.String()).Op("*").Id("Predeclared")
		g.Id("UnexportedFieldStruct").Map(jen.String()).Id("UnexportedFieldStruct")
		g.Id("UnexportedFieldStructPtr").Map(jen.String()).Op("*").Id("UnexportedFieldStruct")
	}).Line()

	f.Func().Id("NewMap").Params().Id("Map").Block(
		jen.Id("p").Op(":=").Id("NewPredeclared").Call(),
		jen.Id("uep").Op(":=").Id("NewUnexportedFieldStruct").Call(),
		jen.Return(jen.Id("Map").Values(jen.DictFunc(func(d jen.Dict) {
			for _, i := range predeclared {
				cap := Capitalize(i.String())
				d[jen.Id(cap)] = jen.Map(jen.Id(i.String())).Id(i.String()).Values(jen.Dict{
					jen.Id("p").Dot(cap): jen.Id("p").Dot(cap),
				})
				d[jen.Id(cap+"Ptr")] = jen.Map(jen.Id(i.String())).Op("*").Id(i.String()).Values(jen.Dict{
					jen.Id("p").Dot(cap): jen.Op("&").Id("p").Dot(cap),
				})
				d[jen.Id(myType(i))] = jen.Map(jen.Id(myType(i))).Id(myType(i)).Values(jen.Dict{
					jen.Id("p").Dot(myType(i)): jen.Id("p").Dot(myType(i)),
				})
				d[jen.Id(myType(i)+"Ptr")] = jen.Map(jen.Id(myType(i))).Op("*").Id(myType(i)).Values(jen.Dict{
					jen.Id("p").Dot(myType(i)): jen.Op("&").Id("p").Dot(myType(i)),
				})
			}

			d[jen.Id("MyMap")] = jen.Id("MyMap").Values(jen.Dict{
				jen.Lit("mymap"): jen.Lit("mymap"),
			})

			d[jen.Id("Struct")] = jen.Map(jen.String()).Id("Predeclared").Values(jen.Dict{
				jen.Lit("struct"): jen.Id("p"),
			})
			d[jen.Id("StructPtr")] = jen.Map(jen.String()).Op("*").Id("Predeclared").Values(jen.Dict{
				jen.Lit("struct"): jen.Op("&").Id("p"),
			})
			d[jen.Id("UnexportedFieldStruct")] = jen.Map(jen.String()).Id("UnexportedFieldStruct").Values(jen.Dict{
				jen.Lit("struct"): jen.Id("uep"),
			})
			d[jen.Id("UnexportedFieldStructPtr")] = jen.Map(jen.String()).Op("*").Id("UnexportedFieldStruct").Values(jen.Dict{
				jen.Lit("struct"): jen.Op("&").Id("uep"),
			})

		}))),
	).Line()

	f.Func().Params(jen.Id("p").Id("Map")).Id("Values").Params().Index().Qual("reflect", "Value").BlockFunc(func(g *jen.Group) {
		g.Var().Id("values").Index().Qual("reflect", "Value")
		for _, i := range predeclared {
			cap := Capitalize(i.String())
			g.Id("values").Op("=").Append(
				jen.Id("values"),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(cap)),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(cap+"Ptr")),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(myType(i))),
				jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot(myType(i)+"Ptr")),
			)
		}
		g.Id("values").Op("=").Append(
			jen.Id("values"),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("MyMap")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("Struct")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("StructPtr")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("UnexportedFieldStruct")),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p").Dot("UnexportedFieldStructPtr")),
		)

		g.Return(jen.Id("values"))
	})
}

func genereateStruct(f *jen.File) {
	f.Type().Id("Struct").StructFunc(func(g *jen.Group) {
		g.Id("Struct").Id("Predeclared")
		g.Id("StructPtr").Op("*").Id("Predeclared")
		g.Id("UnexportedFieldStruct").Id("UnexportedFieldStruct")
		g.Id("UnexportedFieldStructPtr").Op("*").Id("UnexportedFieldStruct")
		g.Id("Anonymous").Struct(
			jen.Id("String").String(),
		)
		g.Id("AnonymousPtr").Op("*").Struct(
			jen.Id("String").String(),
		)
	}).Line()
	f.Func().Id("NewStruct").Params().Id("Struct").Block(
		jen.Id("p").Op(":=").Id("NewPredeclared").Call(),
		jen.Id("uep").Op(":=").Id("NewUnexportedFieldStruct").Call(),
		jen.Return(jen.Id("Struct").Values(jen.DictFunc(func(d jen.Dict) {
			d[jen.Id("Struct")] = jen.Id("p")
			d[jen.Id("StructPtr")] = jen.Op("&").Id("p")
			d[jen.Id("UnexportedFieldStruct")] = jen.Id("uep")
			d[jen.Id("UnexportedFieldStructPtr")] = jen.Op("&").Id("uep")
			d[jen.Id("Anonymous")] = jen.Struct(
				jen.Id("String").String(),
			).Values(jen.Dict{
				jen.Id("String"): jen.Lit("string"),
			})
			d[jen.Id("AnonymousPtr")] = jen.Op("&").Struct(
				jen.Id("String").String(),
			).Values(jen.Dict{
				jen.Id("String"): jen.Lit("string"),
			})
		}))),
	).Line()

	f.Func().Params(jen.Id("p").Id("Struct")).Id("Values").Params().Index().Qual("reflect", "Value").BlockFunc(func(g *jen.Group) {
		g.Var().Id("values").Index().Qual("reflect", "Value")
		g.Id("values").Op("=").Append(
			jen.Id("values"),
			jen.Qual("reflect", "ValueOf").Call(jen.Id("p")),
		)
		g.Return(jen.Id("values"))
	})
}

func value(i reflect.Kind) *jen.Statement {
	var v *jen.Statement
	if i == reflect.Bool {
		v = jen.True()
	} else if i < reflect.Float32 {
		// int
		v = jen.Id(i.String()).Parens(jen.Lit(1))
	} else if i < reflect.Complex64 {
		// float
		v = jen.Id(i.String()).Parens(jen.Lit(3.2))
	} else if i < reflect.Array {
		// complex
		v = jen.Id(i.String()).Parens(jen.Lit(0 + 1i))
	} else if i == reflect.String {
		// string
		v = jen.Lit("Predeclared")
	}
	return v
}

func myType(i reflect.Kind) string {
	return "My" + Capitalize(i.String())
}

func Capitalize(str string) string {
	if len(str) < 1 {
		return ""
	}
	strArry := []rune(str)
	if strArry[0] >= 97 && strArry[0] <= 122 {
		strArry[0] -= 32
	}
	return string(strArry)
}
